#!/usr/bin/env node

/**
 * Load environment vars and set up exceptions
 */
const PIXIE = require('dotenv').config().parsed;

function PixieException(message, status) {
    this.name = 'PixieException';
    this.message = message;
    this.status = status;
}

// process.on('unhandledRejection', (reason, p) => {
//     console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);
// });

/**
 * Module dependencies.
 */

const path = require('path'),
    express = require('express'),
    md5 = require('md5'),
    sharp = require('sharp');

let app = express();


const outputFormats = {
    'jpg': 'jpeg',
    'webp': 'webp',
};

/**
 * Initialize the path for existing assets
 */

let htmlPath = path.normalize(PIXIE.PATH || path.join(__dirname, '..', 'public'));
app.use(express.static(htmlPath, {
    index: false,
    maxAge: 0,
    fallthrough: true
}));

/**
 * Look for paths that have resizing data
 */
app.get(/\/(.*)~~(\d{1,4})x(\d{1,4})(~[0-9a-f]+)?\.(.*)/, function (req, res) {

    try {

        let {0: file, 1: width, 2: height, 3: hash, 4: extension} = req.params;

        // prevent resizing already resized images
        if (file.indexOf('~~') !== -1) {
            throw new PixieException('Duplicate resize forbidden', 404);
        }

        // check for new image format request
        let newExtension = extension,
            oldExtension = extension,
            test = extension.split('.', 2);
        if (test.length === 2) {
            [oldExtension, newExtension] = test;
        }

        validateHashing(file, oldExtension, width, height, hash);

        const originalFile = file + '.' + oldExtension,
            originalPath = path.join(htmlPath, originalFile),
            resizedFile = req.originalUrl.substr(1),
            resizedPath = path.join(htmlPath, resizedFile);

        width = parseInt(width, 10) || null;
        height = parseInt(height, 10) || null;

        sharp(originalPath)
            .resize(width, height)
            .toFormat(outputFormats[newExtension])
            .toFile(resizedPath, function (err, info) {
                if (err) {
                    throw new PixieException(err.message, 500);
                }
                log(req, 200, 'Wrote ' + info.size + ' bytes');
                res.sendFile(resizedPath);
            });

    } catch (e) {
        log(req, e.status, e.message);
        return res.sendStatus(e.status).end();
    }
});

/**
 * Otherwise, abort
 */

app.get('*', (req, res) => {
    log(req, 404);
    return res.sendStatus(404).end();
});

/**
 * Start the server
 */

const port = PIXIE.PORT || 3000;
let server = app.listen(port, () => {
    const host = 'localhost',
        port = server.address().port;
    console.log('Pixie server starting');
    console.log('Static asset path: ' + htmlPath);
    if (PIXIE.HASH) {
        console.log('Enforce hashing:   enabled; length ' + PIXIE.HASH_LENGTH);
    } else {
        console.log('Enforce hashing:   disabled');
    }
    console.log('Listening on:      //' + host + ':' + port + '/');
});


const log = (req, status, message) => {
    if (typeof message === 'undefined') {
        message = '-';
    }

    console.log(
        new Date().toISOString(),
        req.ip,
        'GET', req.originalUrl,
        req.get('Referer') || '-',
        status,
        message
    );
};

const validateHashing = (file, extension, width, height, hash) => {

    // if we aren't hashing, return nothing
    if (!PIXIE.HASH) {
        return;
    }

    // if no has was provided, throw error
    if (typeof hash === 'undefined') {
        throw new PixieException('Missing hash', 403);
    }

    const filename = file + '.' + extension,
        hashLength = -1 * (PIXIE.HASH_LENGTH || 8),
        generatedHash = '~' + md5(filename + width + height + PIXIE.HASH).substr(hashLength);

    // confirm generated hash equals given one
    if (generatedHash !== hash) {
        console.log('Expected hash: ' + generatedHash);
        throw new PixieException('Invalid hash (expected ' + generatedHash + ')', 403);
    }
};
