#!/usr/bin/env node

/**
 * Load environment vars, dependencies, and set up exceptions
 */
const PIXIE = require('dotenv').config().parsed,
    path = require('path'),
    express = require('express'),
    md5 = require('md5'),
    sharp = require('sharp'),
    PixieException = (message, status) => {
        this.name = 'PixieException';
        this.message = message;
        this.status = status;

        return this;
    },
    outputFormats = {
        'jpg': 'jpeg',
        'webp': 'webp',
    },
    cropStrategies = {
        'north': sharp.gravity.north,
        'northeast': sharp.gravity.northeast,
        'east': sharp.gravity.east,
        'southeast': sharp.gravity.southeast,
        'south': sharp.gravity.south,
        'southwest': sharp.gravity.southwest,
        'west': sharp.gravity.west,
        'northwest': sharp.gravity.northwest,
        'center': sharp.gravity.center,
        'centre': sharp.gravity.centre,
        'entropy': sharp.strategy.entropy,
        'attention': sharp.strategy.attention,
    };

/**
 * Build the express app
 */

const app = express();

/**
 * Initialize the path for existing assets
 */

const htmlPath = path.normalize(PIXIE.ROOT || path.join(__dirname, '..', 'public'));
app.use(express.static(htmlPath, {
    index: false,
    maxAge: 0,
    fallthrough: true
}));

/**
 * Look for paths that have resizing data
 */
app.get(/\/(.*)~~(\d{1,4})x(\d{1,4})(~[0-9a-f]+)?\.(.*)/, function (req, res) {

    const cropStrategy = PIXIE.RESIZE_STRATEGY || 'center';

    try {

        let {0: file, 1: width, 2: height, 3: hash, 4: extension} = req.params;

        // prevent resizing already resized images
        if (file.indexOf('~~') !== -1) {
            throw PixieException('Duplicate resize forbidden', 404);
        }

        // check for new image format request
        let newExtension = extension,
            oldExtension = extension,
            test = extension.split('.', 2);
        if (test.length === 2) {
            [oldExtension, newExtension] = test;
        }

        validateHashing(file, oldExtension, width, height, hash);

        const originalFile = file + '.' + oldExtension,
            originalPath = path.join(htmlPath, originalFile),
            resizedFile = req.originalUrl.substr(1),
            resizedPath = path.join(htmlPath, resizedFile);

        width = parseInt(width, 10) || null;
        height = parseInt(height, 10) || null;

        sharp(originalPath)
            .resize(width, height)
            .crop(cropStrategies[cropStrategy])
            .toFormat(outputFormats[newExtension])
            .toFile(resizedPath, function (err, info) {
                if (err) {
                    throw PixieException(err.message, 500);
                }
                log(req, 200, 'Wrote ' + info.size + ' bytes');
                res.sendFile(resizedPath);
            });

    } catch (e) {
        log(req, e.status, e.message);
        return res.sendStatus(e.status).end();
    }
});

/**
 * Otherwise, abort
 */

app.get('*', (req, res) => {
    log(req, 404);
    return res.sendStatus(404).end();
});

/**
 * Start the server
 */

const port = PIXIE.PORT || 3000;
let server = app.listen(port, () => {
    const host = 'localhost',
        port = server.address().port;
    console.log('Pixie server starting');
    console.log('Static asset path: ' + htmlPath);
    if (PIXIE.HASH_SECRET) {
        console.log('Enforce hashing:   enabled; length ' + PIXIE.HASH_LENGTH);
    } else {
        console.log('Enforce hashing:   disabled');
    }
    console.log('Listening on:      //' + host + ':' + port + '/');
});


const log = (req, status, message) => {
    if (typeof message === 'undefined') {
        message = '-';
    }

    console.log(
        new Date().toISOString(),
        req.ip,
        'GET', req.originalUrl,
        req.get('Referer') || '-',
        status,
        message
    );
};

const validateHashing = (file, extension, width, height, hash) => {

    // if we aren't hashing, return nothing
    if (!PIXIE.HASH_SECRET) {
        return;
    }

    // if no has was provided, throw error
    if (typeof hash === 'undefined') {
        throw PixieException('Missing hash', 403);
    }

    const filename = file + '.' + extension,
        hashLength = -1 * (PIXIE.HASH_LENGTH || 8),
        generatedHash = '~' + md5(filename + width + height + PIXIE.HASH_SECRET).substr(hashLength);

    // confirm generated hash equals given one
    if (generatedHash !== hash) {
        console.log('Expected hash: ' + generatedHash);
        throw PixieException('Invalid hash (expected ' + generatedHash + ')', 403);
    }
};
