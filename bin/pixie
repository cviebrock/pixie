#!/usr/bin/env node

/**
 * Load environment vars and set up exceptions
 */
const PIXIE = require('dotenv').config().parsed;

function PixieException(message, status) {
    this.name = 'PixieException';
    this.message = message;
    this.status = status;
}

// process.on('unhandledRejection', (reason, p) => {
//     console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);
// });

/**
 * Module dependencies.
 */

const path = require('path'),
    express = require('express'),
    md5 = require('md5'),
    sharp = require('sharp'),
    fs = require('fs');

let app = express();

/**
 * Initialize the path for existing assets
 */

let htmlPath = path.normalize(PIXIE.PATH || path.join(__dirname, '..', 'public'));
app.use(express.static(htmlPath, {
    index: false,
    maxAge: 0,
    fallthrough: true
}));

/**
 * Look for paths that have resizing data
 */
app.get(/\/(.*)~~(\d{1,4})x(\d{1,4})(~[0-9a-f]+)?\.(.*)/, function (req, res) {

    try {

        const {0: file, 1: width, 2: height, 3: hash, 4: extension} = req.params;

        const generatedHash = validateHashing(file, extension, width, height, hash),
            originalFile = file + '.' + extension,
            originalPath = path.join(htmlPath, originalFile),
            resizedFile = file + '~~' + width + 'x' + height + generatedHash + '.' + extension,
            resizedPath = path.join(htmlPath, resizedFile);

        const w = parseInt(width, 10) || null,
            h = parseInt(height, 10) || null;

        sharp(originalPath)
            .resize(w, h)
            .toFile(resizedPath, function (err, info) {
                if (err) {
                    throw new PixieException(err.message, 500);
                }
                log(req, 200, 'Created ' + info.size + ' bytes');
                res.sendFile(resizedPath);
            });

    } catch (e) {
        log(req, e.status, e.message);
        return res.status(e.status).send(e.message).end();
    }
});

/**
 * Otherwise, abort
 */

app.get('*', (req, res) => {
    log(req, 404);
    return res.sendStatus(404).end();
});

/**
 * Start the server
 */

let port = PIXIE.PORT || 3000;
let server = app.listen(port, () => {
    let host = 'localhost',
        port = server.address().port;
    console.log('Pixie server starting');
    console.log('Static asset path: ' + htmlPath);
    if (PIXIE.HASH) {
        console.log('Enforce hashing:   enabled; length ' + PIXIE.HASH_LENGTH);
    } else {
        console.log('Enforce hashing:   disabled');
    }
    console.log('Listening on:      //' + host + ':' + port + '/');
});


function log(req, status, message) {
    if (typeof message === 'undefined') {
        message = '-';
    }

    console.log(
        new Date().toISOString(),
        req.ip,
        'GET', req.originalUrl,
        req.get('Referer') || '-',
        status,
        message
    );
}

function validateHashing(file, extension, width, height, hash) {

    // if we aren't hashing, return nothing
    if (!PIXIE.HASH) {
        return '';
    }

    // if no has was provided, throw error
    if (typeof hash === 'undefined') {
        throw new PixieException('Missing hash', 403);
    }

    const filename = file + '.' + extension,
        hashLength = -1 * (PIXIE.HASH_LENGTH || 8),
        generatedHash = '~' + md5(filename + width + height + PIXIE.HASH).substr(hashLength);

    // confirm generated hash equals given one
    if (generatedHash !== hash) {
        console.log('Expected hash: '+generatedHash);
        throw new PixieException('Invalid hash', 403);
    }

    return generatedHash;
}
